# Анализ

## Описание работы и время работы

Бинарный поиск предполагает, на входе мы имеем отсортированный ~~массив~~ набор
данных. В нашем случае мы имеем отсортированный массив сдвинутый на некое k. 
Точкой сдвига назовем индекс ячейки с наименьшим элементом массива. Т.к. 
наименьший элемент массива один - точка сдвига тоже только одна.

Например:
19, 21, 100, 101, 1, 4, 5, 7, 12
                  ^ 

В реализации используется модифицированная версия бинарного поиска. Докажем, что она работает за O(logn).

Для заявленного времени работы мы должны каждый раз делить массив приблизительно пополам (длина массива не всегда четная) и рекурсивно вызывать 
модифицированный бинарный поиск только для одной из половинок. 

Какие половинки у нас могут получиться после деления:
1. Массив поделен ровно по точке сдвига и мы имеем два сортированных массива
2. Точка сдвига оказалась в левой половине, тогда правая половина отсортирована
3. Тогда сдвига оказалась в правой половина, тогда левая полова отсорирована.

Т.е. в каждом из случаев есть одна отсортированная половина. Её первый и последний элементы - минимальный и максимальный элемент соответственно. Зная их
мы можем понять, входит ли в этот диапазон искомое значение. Если входит - 
делаем рекурсивный выхов на этой половине, если нет - на другой.

Таким образом, каждый раз мы обрабатываем только половину входного массива.

## Память

Рекурсивная реализация бинарного поиска использует суммарно O(logn) памяти на стеке (logn - глубина стека, O(1) под переменные в каждом фрейме)


